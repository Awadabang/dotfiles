#!/usr/bin/env bash
# yadm bootstrap script
# Installs all my packages/sets up my environment.
#
# Checks for the presence of the $ON_OS variable,
# which is set in ~/.profile by checking `uname`
# on linux. Since the ~/.profile is sourced at the
# beginning of the Xsession and not when opening
# a shell, it can be assumed that its always set
# once `yadm clone` has been run and the computer
# has been restarted.

need_cmd() {
  if ! check_cmd "$1"; then
    err "need '$1' (command not found)"
  fi
}

check_cmd() {
  command -v "$1" > /dev/null 2>&1
}

# This wraps curl or wget. Try curl first, if not installed,
# use wget instead.
downloader() {
  local _dld
  if check_cmd curl; then
    _dld=curl
  elif check_cmd wget; then
    _dld=wget
  else
    _dld='curl or wget' # to be used in error message of need_cmd
  fi

  if [ "$1" = --check ]; then
    need_cmd "$_dld"
  elif [ "$_dld" = curl ]; then
    if [ -z "$2" ]; then
      curl --silent --show-error --fail --location "$1"
    else
      curl --silent --show-error --fail --location "$1" --output "$2"
    fi
  elif [ "$_dld" = wget ]; then
    if [ -z "$2" ]; then
      wget "$1"
    else
      wget "$1" -O "$2"
    fi
  else
    err "Unknown downloader"   # should not reach here
  fi
}
downloader --check

print_error() {
	havecmd notify 2>/dev/null && notify -u critical "bootstrap error" "$1"
	printf '%s%s%s\n' "$(tput setaf 1)" "$1" "$(tput sgr0)" 1>&2
} && export -f print_error

abort() {
	print_error "$1"
	exit 1
} && export -f abort

declare -rx YADM_DIR="${HOME}/.config/yadm"

# report errors if user doesn't have a command
export HAVECMD_REPORT=1

# make sure my $PATH is setup properly
havecmd havecmd || {
	# optionally let me continue - this may be the first time I'm running this
	# on android and I need to install zsh/setup defaults
	printf 'No havecmd; continue anyways? [Ctrl+C to Cancel] '
	read -r || exit $?
}

ON_OS="${ON_OS:=}"
OS_TYPE="$(uname -s)"
case "${OS_TYPE}" in
    Linux*)
        ON_OS="linux"
        ;;
    Darwin*)
        ON_OS="macos"
        ;;
    CYGWIN*|MINGW32*|MSYS*|MINGW*)
        ON_OS="windows"  # Windows 下的 bash 环境（如 Git Bash）
        ;;
     *)
        ON_OS="unknown"
        ;;
esac
declare -rx ON_OS

havecmd git || exit $?
echo 'Checking git config...'
# check for global name config
if [[ -z $(git config --global user.name) ]]; then
	printf "No global name set. Enter name: "
	read -r githubusername
	git config --global user.name "${githubusername}"
fi
# check for global email config
if [[ -z $(git config --global user.email) ]]; then
	if [[ -n "$GITHUB_EMAIL" ]]; then
		git config --global user.email "$GITHUB_EMAIL"
	else
		printf "No global email set. Enter email connected to your GitHub account: "
		read -r githubemail
		git config --global user.email "${githubemail}"
	fi
fi

# set editor to use as nvim
git config --global core.editor vim
# specify how to handle divergent branches
git config --global pull.rebase false
git config --global core.pager 'less -i'
# set similar configuration for yadm itself
yadm gitconfig core.editor vim
yadm gitconfig pull.rebase false
yadm gitconfig core.pager 'less -i'
case "$ON_OS" in
linux_arch*)
	git config --global core.pager 'delta'
	yadm gitconfig core.pager 'delta'
	;;
esac

# set the hooks directory
yadm gitconfig core.hooksPath "${HOME}/.config/yadm/hooks"

# 检查 mise 是否已安装，如果未安装则尝试自动安装
if ! command -v mise &> /dev/null; then
    echo "mise 未安装，正在尝试自动安装..."
    curl https://mise.run | sh
    # 注意：安装脚本通常会将 mise 安装到 ~/.local/bin 或类似目录
    # 你可能需要在安装后手动将其添加到 PATH，或者重新登录/重启终端
    echo "mise 安装脚本已运行，请确保 ~/.local/bin 在你的 PATH 中，然后重新启动终端或运行: source ~/.bashrc"
fi

# 安装goup 和 go
if !command -v goup &> /dev/null; then
    echo "Installing goup&go..."
    downloader "https://github.com/owenthereal/goup/releases/latest/download" "$HOME/.go/bin/goup"
    chmod u+x "$HOME/.go/bin/goup"
fi

# Source Bash 脚本
echo "Sourcing bash configuration files..."

# 定义需要 source 的 bash 文件列表
bash_files=(
    "${HOME}/.bashrc"
    "${HOME}/.bash_profile"
    "${HOME}/.profile"
)

# 遍历并 source 每个存在的文件
for bash_file in "${bash_files[@]}"; do
    if [[ -f "$bash_file" ]]; then
        echo "Sourcing $bash_file..."
        # 使用 source 或者 . 命令
        # 注意：在脚本中 source 这些文件会影响当前脚本的环境，但不会影响父 shell
        source "$bash_file" || {
            print_error "Failed to source $bash_file"
            continue
        }
    else
        echo "Note: $bash_file does not exist, skipping..."
    fi
done

# 如果是交互式 shell，还可以重新加载 completion
if [[ $- == *i* ]]; then
    echo "Reloading bash completion..."
    havecmd bash && {
        # 重新加载 completion 系统（如果存在）
        if [[ -f /usr/share/bash-completion/bash_completion ]]; then
            source /usr/share/bash-completion/bash_completion
        elif [[ -f /etc/bash_completion ]]; then
            source /etc/bash_completion
        fi
    }
fi

echo "Bash configuration reloaded!"

echo "yadm bootstrap success!"
